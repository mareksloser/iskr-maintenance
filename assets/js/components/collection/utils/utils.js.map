{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../src/utils/utils.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,MAAM,CAAC,KAAa,EAAE,MAAc,EAAE,IAAY;EACjE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAA;AAC/E,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,KAAK,CAAC,WAAmB;EAC9C,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAA;AAChE,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,CAAoB,EAAE,KAAa;EAC3D,IAAI,KAAK,GAAQ,CAAC,CAAA;EAClB,OAAO,UAAU,GAAG,IAAI;IACvB,YAAY,CAAC,KAAK,CAAC,CAAA;IACnB,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,KAAK,CAAC,CAAA;EACrD,CAAC,CAAA;AACF,CAAC;AAED;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,GAAG,GAAG,CAA6C,IAAO,EAAE,GAAM,EAA2B,EAAE;EAC3G,OAAO,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;AACvD,CAAC,CAAA;AAED;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAsC,IAAO,EAAE,MAAS,EAAE,EAAE;EACnF,OAAO,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;AACpD,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,IAAI,GAAG,CAAuD,GAAM,EAAE,IAAkB,EAAc,EAAE,CACpH,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,CAAE,IAA0B,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAe,CAAA","sourcesContent":["export function format(first: string, middle: string, last: string): string {\n\treturn (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '')\n}\n\nexport async function delay(miliseconds: number): Promise<void> {\n\treturn new Promise(resolve => setTimeout(resolve, miliseconds))\n}\n\nexport function throttle(f: (entries) => void, delay: number) {\n\tlet timer: any = 0\n\treturn function (...args) {\n\t\tclearTimeout(timer)\n\t\ttimer = setTimeout(() => f.apply(this, args), delay)\n\t}\n}\n\n/**\n * Checks if object has that property\n *\n * @param {K} prop\n * @param {T} obj\n * @return {obj is T & Record<K, V>}\n */\nexport const has = <T extends object, K extends PropertyKey, V>(prop: K, obj: T): obj is T & Record<K, V> => {\n\treturn Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Returns property of given Object\n *\n * @param {K} name\n * @param {T} object\n * @return {(T & Record<K, unknown>)[K]}\n */\nexport const property = <T extends object, K extends keyof T>(name: K, object: T) => {\n\treturn has(name, object) ? object[name] : undefined\n}\n\nexport const pick = <T extends Record<string, unknown>, K extends keyof T>(obj: T, keys: readonly K[]): Pick<T, K> =>\n\tObject.fromEntries(Object.entries(obj).filter(([key]) => (keys as readonly string[]).includes(key))) as Pick<T, K>\n"]}